<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>12 - Materials</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lil-gui@0.19.2/dist/lil-gui.min.css">
        <script src="https://aframe.io/releases/0.9.2/aframe.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.1/three.module.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.2/dist/lil-gui.umd.min.js"></script>
    </head>
    <body style='margin: 0; overflow: hidden;'>
        <a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false;'>
            <a-marker type='pattern' url='pattern-marker.patt'>
                <a-entity id="threejs-object"></a-entity>
            </a-marker>
            <a-entity id="camera" camera position="0 0 5" look-controls></a-entity>
        </a-scene>
        <script>
            const debug = new lil.GUI();

            /**
             * Textures
             */
            const textureLoader = new THREE.TextureLoader();
            const doorColorTexture = textureLoader.load('./textures/door/color.jpg');
            const doorAlphaTexture = textureLoader.load('./textures/door/alpha.jpg');
            const doorAmbientOcclusionTexture = textureLoader.load('./textures/door/ambientOcclusion.jpg');
            const doorHeightTexture = textureLoader.load('./textures/door/height.jpg');
            const doorNormalTexture = textureLoader.load('./textures/door/normal.jpg');
            const doorMetalnessTexture = textureLoader.load('./textures/door/metalness.jpg');
            const doorRoughnessTexture = textureLoader.load('./textures/door/roughness.jpg');
            const matcapTexture = textureLoader.load('./textures/matcaps/8.png');
            const gradientTexture = textureLoader.load('./textures/gradients/5.jpg');

            doorColorTexture.colorSpace = THREE.SRGBColorSpace;
            matcapTexture.colorSpace = THREE.SRGBColorSpace;

            /**
             * Base
             */
            const scene = new THREE.Scene();

            /**
             * Mesh
             */
            const geometrySphere = new THREE.SphereGeometry(1, 64, 64, 0);
            const geometryPlane = new THREE.BoxGeometry(1, 1, 0.5, 50, 50, 50);
            const geometryTorus = new THREE.TorusGeometry(0.5, 0.2, 64, 128);

            const material = new THREE.MeshPhysicalMaterial();
            material.metalness = 0;
            material.roughness = 0.25;
            material.side = THREE.DoubleSide;
            material.iridescence = 1;
            material.iridescenceIOR = 1;
            material.iridescenceThicknessRange = [100, 800];
            material.transmission = 1;
            material.ior = 1.5;
            material.thickness = 0.5;

            debug.add(material, "metalness").min(0).max(1).step(0.01).name("金屬反光");
            debug.add(material, "roughness").min(0).max(1).step(0.01).name("粗糙程度");
            debug.add(material, "iridescence").min(0).max(1).step(0.1).name("繞射虹彩");
            debug.add(material, "iridescenceIOR").min(1).max(2.333).step(0.1).name("虹彩折射率");
            debug.add(material.iridescenceThicknessRange, "0").min(1).max(1000).step(1).name("虹彩色彩範圍(min)");
            debug.add(material.iridescenceThicknessRange, "1").min(1).max(1000).step(1).name("虹彩色彩範圍(max)");
            debug.add(material, "transmission").min(0).max(1).step(0.001).name("透明度");
            debug.add(material, "ior").min(1).max(10).step(0.001).name("折射率");
            debug.add(material, "thickness").min(0).max(1).step(0.01).name("折射厚度");

            const meshSphere = new THREE.Mesh(geometrySphere, material);
            const meshPlane = new THREE.Mesh(geometryPlane, material);
            const meshTorus = new THREE.Mesh(geometryTorus, material);
            meshSphere.position.x = -3;
            meshTorus.position.x = 2;

            scene.add(meshSphere, meshPlane, meshTorus);

            const envLoader = new THREE.TextureLoader();
            envLoader.load("./textures/environmentMap/1k.jpg", (environmentMap) => {
                environmentMap.mapping = THREE.EquirectangularReflectionMapping;
                environmentMap.colorSpace = THREE.SRGBColorSpace;
                scene.background = environmentMap;
                scene.environment = environmentMap;
            });

            /**
             * Sizes
             */
            const sizes = {
                width: window.innerWidth,
                height: window.innerHeight
            };

            window.addEventListener('resize', () => {
                // Update sizes
                sizes.width = window.innerWidth;
                sizes.height = window.innerHeight;
            });

            /**
             * Animate
             */
            const clock = new THREE.Clock();

            const tick = () => {
                const elapsedTime = clock.getElapsedTime();

                meshSphere.rotation.y = 0.1 * elapsedTime;
                meshPlane.rotation.y = 0.1 * elapsedTime;
                meshTorus.rotation.y = 0.1 * elapsedTime;

                meshSphere.rotation.x = -0.15 * elapsedTime;
                meshPlane.rotation.x = -0.15 * elapsedTime;
                meshTorus.rotation.x = -0.15 * elapsedTime;

                // Call tick again on the next frame
                window.requestAnimationFrame(tick);
            };

            tick();

            // Function to change camera position
            const changeCameraPosition = (x, y, z) => {
                const cameraEl = document.querySelector('#camera');
                if (cameraEl) {
                    cameraEl.setAttribute('position', `${x} ${y} ${z}`);
                }
            };

            // Example of changing camera position
            changeCameraPosition(2, 2, 2);
        </script>
    </body>
</html>
