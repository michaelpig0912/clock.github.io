<!DOCTYPE html>
<html>
<head>
    <title>運動追蹤分析系統</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .video-container, .analysis-container {
            flex: 1;
            min-width: 300px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .video-wrapper {
            position: relative;
            width: 100%;
            background: #000;
            margin-bottom: 20px;
        }

        #videoElement, #trackingCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0056b3;
        }

        .settings {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        .settings > div {
            flex: 1;
            min-width: 200px;
        }

        select, input[type="color"], input[type="range"] {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        .recorded-videos {
            margin-top: 20px;
        }

        .recorded-video-item {
            margin-bottom: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .recorded-video-item video {
            width: 100%;
            border-radius: 5px;
        }

        .graph-container {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        #xtGraph, #ytGraph ,#vxtGraph, #vytGraph{
            width: 100%;
            height: 200px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .video-container, .analysis-container {
                width: 100%;
            }

            .controls {
                flex-direction: column;
            }

            button {
                width: 100%;
            }
        }

        .video-controls {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .progress-container {
            margin-bottom: 10px;
        }

        #videoProgress {
            width: 100%;
            height: 5px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2.5px;
            cursor: pointer;
        }

        #videoProgress::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        #videoProgress::-moz-range-thumb {
            width: 15px;
            height: 15px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .time-display {
            color: white;
            font-size: 14px;
            text-align: right;
            margin-top: 5px;
        }

        .control-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .control-buttons button {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 5px 15px;
            border-radius: 3px;
            transition: background-color 0.2s, transform 0.2s;
            position: relative;
            overflow: hidden;
        }

        .control-buttons button::before {
            content: none !important; /* 移除任何内容 */
        }

        .control-buttons button:hover::before {
            transform: translate(-50%, -50%) scale(1);
        }

        .control-buttons button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }

        .tab-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab-button {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: #f8f9fa;
            cursor: pointer;
            border-radius: 5px;
        }

        .tab-button.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="video-container">
            <div class="video-wrapper">
                <video id="videoElement"></video>
                <canvas id="trackingCanvas"></canvas>
            </div>
            
            <div class="video-controls">
                <!-- 進度條 -->
                <div class="progress-container">
                    <input type="range" id="videoProgress" min="0" max="100" value="0" step="0.1">
                    <div class="time-display">
                        <span id="currentTime">00:00</span> / <span id="duration">00:00</span>
                    </div>
                </div>
                
                <!-- 播放控制按鈕 -->
                <div class="control-buttons">
                    <button id="stepBackward" title="上一幀"><i class="fas fa-step-backward"></i></button>
                    <button id="playPause" title="播放/暫停"><i class="fas fa-play"></i></button>
                    <button id="stepForward" title="下一幀"><i class="fas fa-step-forward"></i></button>
                </div>
            </div>

            <div class="settings">
                <div>
                    <label for="colorPicker">追蹤顏色：</label>
                    <input type="color" id="colorPicker" value="#ff0000">
                </div>
                <div>
                    <label for="tolerance">容差：</label>
                    <input type="range" id="tolerance" min="0" max="100" value="10">
                    <span id="toleranceValue">10</span>
                </div>
            </div>

            <div class="controls">
                <input type="file" id="videoUpload" accept="video/*">
                <button id="exportVideo">匯出軌跡圖</button>
                <button id="exportData">匯出圖表數據</button>
                <button id="toggleTrackingMode">切換到手動追蹤</button>
                <button id="toggleTrailMode">軌跡模式: 顯示</button>
                <button id="clearAll">清除所有內容</button>
            </div>
        </div>

        <div class="analysis-container">
            <div class="tab-controls">
                <button class="tab-button active" data-tab="position">位置圖表</button>
                <button class="tab-button" data-tab="velocity">速度圖表</button>
            </div>
            
            <div class="tab-content" id="positionTab">
                <div class="graph-container">
                    <h3>X-T 圖</h3>
                    <canvas id="xtGraph"></canvas>
                    <h3>Y-T 圖</h3>
                    <canvas id="ytGraph"></canvas>
                </div>
            </div>
            
            <div class="tab-content" id="velocityTab" style="display: none;">
                <div class="graph-container">
                    <h3>Vx-T 圖</h3>
                    <canvas id="vxtGraph"></canvas>
                    <h3>Vy-T 圖</h3>
                    <canvas id="vytGraph"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        class VideoController {
            constructor() {
                this.video = document.getElementById('videoElement');
                this.trackingCanvas = document.getElementById('trackingCanvas');
                this.ctx = this.trackingCanvas.getContext('2d');
                this.currentTime = 0;
                this.progressBar = document.getElementById('videoProgress');
                this.currentTimeDisplay = document.getElementById('currentTime');
                this.durationDisplay = document.getElementById('duration');
                this.playPauseButton = document.getElementById('playPause');
                this.stepForwardButton = document.getElementById('stepForward');
                this.stepBackwardButton = document.getElementById('stepBackward');
                
                this.isPlaying = false;
                this.frameTime = 1/30;
                this.dataChunks = [];
                
                this.setupEventListeners();
                this.setupVideoControls();
                this.video.addEventListener('loadedmetadata', () => this.adjustCanvasSize());
            }

            setupEventListeners() {
                const videoUpload = document.getElementById('videoUpload');
                
                videoUpload.addEventListener('change', (e) => this.handleVideoUpload(e));
                document.getElementById('exportVideo').addEventListener('click', () => this.exportGraphs());
                document.getElementById('exportData').addEventListener('click', () => this.exportData());
                
                this.video.addEventListener('play', () => objectTracker.startTracking());
                this.video.addEventListener('pause', () => objectTracker.stopTracking());
                
                document.getElementById('toggleTrackingMode').addEventListener('click', () => {
                    this.clearAll();
                    
                    objectTracker.isManualMode = !objectTracker.isManualMode;
                    document.getElementById('toggleTrackingMode').textContent = 
                        objectTracker.isManualMode ? '切換到自動追蹤' : '切換到手動追蹤';
                });

                document.getElementById('clearAll').addEventListener('click', () => this.clearAll());
            }

            handleVideoUpload(event) {
                const file = event.target.files[0];
                if (file) {
                    this.clearAll();
                    
                    const url = URL.createObjectURL(file);
                    this.video.srcObject = null;
                    this.video.src = url;
                    this.video.load();
                    this.trackingData = [];
                    this.video.onloadedmetadata = () => {
                        this.adjustCanvasSize();
                        this.trackingCanvas.width = this.video.videoWidth;
                        this.trackingCanvas.height = this.video.videoHeight;
                        this.updateDurationDisplay();
                    };
                    
                    const playVideoBtn = document.getElementById('playVideo');
                    const pauseVideoBtn = document.getElementById('pauseVideo');
                    
                    if (playVideoBtn) {
                        playVideoBtn.addEventListener('click', () => this.video.play());
                    }
                    if (pauseVideoBtn) {
                        pauseVideoBtn.addEventListener('click', () => this.video.pause());
                    }
                }
            }

            adjustCanvasSize() {
                const videoAspect = this.video.videoWidth / this.video.videoHeight;
                const wrapper = this.video.parentElement;
                
                // 設置 wrapper 的高度以保持影片比例
                wrapper.style.height = `${wrapper.offsetWidth / videoAspect}px`;
                
                // 設置 canvas 的實際尺寸為影片的尺寸
                this.trackingCanvas.width = this.video.videoWidth;
                this.trackingCanvas.height = this.video.videoHeight;
                
                // 設置 canvas 的顯示尺寸以匹配影片
                this.trackingCanvas.style.width = `${this.video.offsetWidth}px`;
                this.trackingCanvas.style.height = `${this.video.offsetHeight}px`;
            }

            setupVideoControls() {
                // 當影片載入完成時
                this.video.addEventListener('loadedmetadata', () => {
                    this.progressBar.max = this.video.duration;
                    this.updateTimeDisplay();
                    this.updateDurationDisplay();
                });

                // 影片時間更新時
                this.video.addEventListener('timeupdate', () => {
                    if (!this.progressBar.dragging) {
                        this.progressBar.value = this.video.currentTime;
                        this.updateTimeDisplay();
                    }
                });

                // 播放狀態改變時
                this.video.addEventListener('play', () => {
                    this.isPlaying = true;
                    this.playPauseButton.innerHTML = '<i class="fas fa-pause"></i>'; // 使用 Font Awesome 的暂停图标
                });

                this.video.addEventListener('pause', () => {
                    this.isPlaying = false;
                    this.playPauseButton.innerHTML = '<i class="fas fa-play"></i>'; // 使用 Font Awesome 的播放图标
                });

                // 進度條控制
                this.progressBar.addEventListener('mousedown', () => {
                    this.progressBar.dragging = true;
                });

                this.progressBar.addEventListener('mouseup', () => {
                    this.progressBar.dragging = false;
                });

                this.progressBar.addEventListener('input', () => {
                    this.video.currentTime = this.progressBar.value;
                    this.updateTimeDisplay();
                });

                // 播放/暫停按鈕
                this.playPauseButton.addEventListener('click', () => {
                    if (this.isPlaying) {
                        this.video.pause();
                        this.playPauseButton.innerHTML = '<i class="fas fa-play"></i>'; // 使用 Font Awesome 的播放图标
                    } else {
                        this.clearAll(); // 在開始播放前清除所有內容
                        this.video.play();
                        this.playPauseButton.innerHTML = '<i class="fas fa-pause"></i>'; // 使用 Font Awesome 的暂停图标
                    }
                });

                // 逐幀控制
                this.stepForwardButton.addEventListener('click', () => {
                    this.video.pause();
                    this.video.currentTime = Math.min(
                        this.video.duration, 
                        this.video.currentTime + this.frameTime
                    );
                });

                this.stepBackwardButton.addEventListener('click', () => {
                    this.video.pause();
                    this.video.currentTime = Math.max(
                        0, 
                        this.video.currentTime - this.frameTime
                    );
                });

                // 鍵盤控制
                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case ' ': // 空格鍵
                            e.preventDefault();
                            if (this.isPlaying) {
                                this.video.pause();
                            } else {
                                this.video.play();
                            }
                            break;
                        case 'ArrowLeft': // 左箭頭
                            e.preventDefault();
                            this.video.currentTime = Math.max(0, this.video.currentTime - this.frameTime);
                            break;
                        case 'ArrowRight': // 右箭頭
                            e.preventDefault();
                            this.video.currentTime = Math.min(
                                this.video.duration, 
                                this.video.currentTime + this.frameTime
                            );
                            break;
                    }
                });
            }

            updateTimeDisplay() {
                this.currentTimeDisplay.textContent = this.formatTime(this.video.currentTime);
            }

            updateDurationDisplay() {
                if (this.video.duration) {
                    this.durationDisplay.textContent = this.formatTime(this.video.duration);
                } else {
                    this.durationDisplay.textContent = "00:00";
                }
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
            }

            clearAll() {
                // 清除追蹤數據
                this.trackingData = [];
                objectTracker.manualPoints = []; // 清除動追蹤點
                objectTracker.detectedPoints = []; // 清除自動追蹤點
                objectTracker.lastPosition = null; // 重置最後位置

                // 清除畫布
                this.ctx.clearRect(0, 0, this.trackingCanvas.width, this.trackingCanvas.height);

                // 清除圖表
                graphRenderer.clearGraphs();

                // 重置影片時間到開始位置
                this.video.currentTime = 0;
                this.video.pause(); // 順便暫停影片
            }

            exportGraphs() {
                // 創建一個新的 canvas
                const exportCanvas = document.createElement('canvas');
                const video = this.video;
                const trackingCanvas = this.trackingCanvas;
                
                // 設置匯出 canvas 的大小為影片實際大小
                exportCanvas.width = video.videoWidth;
                exportCanvas.height = video.videoHeight;
                
                const ctx = exportCanvas.getContext('2d');
                
                // 繪製當前影片幀
                ctx.drawImage(video, 0, 0, exportCanvas.width, exportCanvas.height);
                
                // 繪製追蹤跡
                ctx.drawImage(trackingCanvas, 0, 0, exportCanvas.width, exportCanvas.height);
                
                // 如果是手動模式，添加點的編號
                if (objectTracker.isManualMode && objectTracker.manualPoints.length > 0) {
                    objectTracker.manualPoints.forEach((point, index) => {
                        const x = point.x;
                        const y = point.y;
                        
                        // 繪製點的編號
                        ctx.strokeStyle = 'black';
                        ctx.fillStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.strokeText((index + 1).toString(), x + 10, y - 10);
                        ctx.fillText((index + 1).toString(), x + 10, y - 10);
                    });
                }
                
                // 將 canvas 轉換為圖片並下載
                try {
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    link.download = `motion-tracking-${timestamp}.png`;
                    link.href = exportCanvas.toDataURL('image/png');
                    link.click();
                } catch (error) {
                    console.error('匯出圖片失敗:', error);
                    alert('匯出圖片失敗，請稍後再試');
                }
            }

            exportData() {
                const data = this.trackingData;
                if (!data || data.length === 0) {
                    alert('沒有可匯出的數據！');
                    return;
                }

                // 創建 CSV 內容
                let csvContent = 'Time (s),X Position (px),Y Position (px),X Velocity (px/s),Y Velocity (px/s)\n';

                // 計算速度
                data.forEach((point, index) => {
                    let vx = 0;
                    let vy = 0;

                    // 計算速度（使用前後兩點計算）
                    if (index > 0 && index < data.length - 1) {
                        const dt = data[index + 1].time - data[index - 1].time;
                        if (dt !== 0) {
                            vx = (data[index + 1].x - data[index - 1].x) / (2 * dt);
                            vy = (data[index + 1].y - data[index - 1].y) / (2 * dt);
                        }
                    }

                    // 格式化數據，保留三位小數
                    const formattedTime = point.time.toFixed(3);
                    const formattedX = point.x.toFixed(1);
                    const formattedY = point.y.toFixed(1);
                    const formattedVx = vx.toFixed(1);
                    const formattedVy = vy.toFixed(1);

                    csvContent += `${formattedTime},${formattedX},${formattedY},${formattedVx},${formattedVy}\n`;
                });

                // 創建並下載 CSV 文件
                try {
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `motion-data-${timestamp}.csv`;
                    link.click();
                    URL.revokeObjectURL(link.href);
                } catch (error) {
                    console.error('匯出數據失敗:', error);
                    alert('匯出數據失敗，請稍後再試');
                }
            }
        }

        class ObjectTracker {
            constructor(videoController) {
                this.videoController = videoController;
                this.tracking = false;
                this.colorPicker = document.getElementById('colorPicker');
                this.tolerance = document.getElementById('tolerance');
                this.toleranceValue = document.getElementById('toleranceValue');
                this.selectedPoint = null;
                this.detectedPoints = [];
                this.setupCanvas();
                this.setupEventListeners();
                this.lastProcessTime = 0; // 用於控制處理頻率
                this.isManualMode = false; // 添加手動模式標記
                this.manualPoints = []; // 存儲手動加的點
                this.lastPosition = null; // 儲存前一幀的位置
                this.searchRadius = 50;   // 搜索半徑（像素）
                this.trailMode = 'show'; // 'show', 'fade', 'hide'
                this.trailLength = 3; // 改為只顯示最後 3 個點（原本是 5）
                this.setupTrailMode();

                this.tolerance.addEventListener('input', () => {
                    this.toleranceValue.textContent = this.tolerance.value;
                });

                // 添加新的屬性
                this.frameInterval = 1000 / 30; // 30fps 的間隔時間
                this.maxFrameSkip = 5; // 最大允許跳過的幀數
                this.lastTrackingTime = 0;
                this.missedFrames = 0;

                // 添加手動追蹤的初始化
                this.setupManualTracking();
            }

            setupCanvas() {
                this.videoController.trackingCanvas.width = this.videoController.video.videoWidth || 640;
                this.videoController.trackingCanvas.height = this.videoController.video.videoHeight || 480;
                this.videoController.ctx = this.videoController.trackingCanvas.getContext('2d', { 
                    willReadFrequently: true 
                });
            }

            setupEventListeners() {
                this.videoController.trackingCanvas.addEventListener('click', (e) => {
                    const rect = this.videoController.trackingCanvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left) * (this.videoController.trackingCanvas.width / rect.width);
                    const y = (e.clientY - rect.top) * (this.videoController.trackingCanvas.height / rect.height);
                    
                    if (!this.isManualMode) {
                        const ctx = this.videoController.ctx;
                        
                        ctx.drawImage(this.videoController.video, 0, 0, this.videoController.trackingCanvas.width, this.videoController.trackingCanvas.height);
                        
                        const imageData = ctx.getImageData(x, y, 1, 1).data;
                        const color = `#${imageData[0].toString(16).padStart(2, '0')}${imageData[1].toString(16).padStart(2, '0')}${imageData[2].toString(16).padStart(2, '0')}`;
                        this.colorPicker.value = color;
                        
                        const displayScale = rect.width / this.videoController.trackingCanvas.width;
                        const circleRadius = 5 / displayScale; // 保持視覺上 5px 的大小
                        
                        ctx.beginPath();
                        ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
                        ctx.strokeStyle = 'RED';
                        ctx.lineWidth = 2 / displayScale; // 線寬也要縮放
                        ctx.stroke();

                    }
                });
            }

            findClosestPoint(x, y) {
                if (this.detectedPoints.length === 0) return null;

                return this.detectedPoints.reduce((closest, point) => {
                    const distance = Math.hypot(x - point.x, y - point.y);
                    if (!closest || distance < closest.distance) {
                        return { ...point, distance };
                    }
                    return closest;
                }, null);
            }

            startTracking() {
                this.tracking = true;
                this.track();
            }

            stopTracking() {
                this.tracking = false;
                this.detectedPoints = []; // 停止追蹤時清除檢測到的點
            }

            track() {
                if (!this.tracking) return;

                const now = performance.now();
                const timeSinceLastTrack = now - this.lastTrackingTime;

                // 如果距離上次追蹤的時間超過幀間隔，進行追蹤
                if (timeSinceLastTrack >= this.frameInterval) {
                    const framesMissed = Math.floor(timeSinceLastTrack / this.frameInterval);
                    
                    // 如果跳過太多幀，進行插值計算
                    if (framesMissed > 1 && framesMissed <= this.maxFrameSkip && this.lastPosition) {
                        this.interpolateMissedFrames(framesMissed);
                    }

                    const ctx = this.videoController.ctx;
                    const video = this.videoController.video;
                    
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    ctx.drawImage(video, 0, 0, ctx.canvas.width, ctx.canvas.height);

                    if (!this.isManualMode) {
                        const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
                        const targetColor = this.hexToRgb(this.colorPicker.value);
                        const tolerance = parseInt(this.tolerance.value);

                        // 擴大搜索範圍
                        const searchRegion = this.lastPosition ? {
                            x: Math.max(0, this.lastPosition.x - this.searchRadius * 1.5),
                            y: Math.max(0, this.lastPosition.y - this.searchRadius * 1.5),
                            width: Math.min(ctx.canvas.width, this.searchRadius * 3),
                            height: Math.min(ctx.canvas.height, this.searchRadius * 3)
                        } : {
                            x: 0,
                            y: 0,
                            width: ctx.canvas.width,
                            height: ctx.canvas.height
                        };

                        const targetRegion = this.findTargetInRegion(
                            imageData, 
                            targetColor, 
                            tolerance, 
                            searchRegion
                        );

                        if (targetRegion) {
                            this.missedFrames = 0;
                            this.lastPosition = {
                                x: targetRegion.centerX,
                                y: targetRegion.centerY,
                                time: video.currentTime
                            };

                            this.detectedPoints.push(this.lastPosition);
                            this.videoController.trackingData.push({
                                time: video.currentTime,
                                x: targetRegion.centerX,
                                y: targetRegion.centerY
                            });

                            graphRenderer.updateGraphs(this.videoController.trackingData);
                            this.drawDetectedPoints();
                        } else {
                            this.missedFrames++;
                            // 如果連續多次找不到目標，嘗試在更大範圍內搜索
                            if (this.missedFrames > 3) {
                                this.searchRadius = Math.min(this.searchRadius * 1.5, 150);
                            }
                        }
                    }

                    this.lastTrackingTime = now;
                }

                requestAnimationFrame(() => this.track());
            }

            interpolateMissedFrames(framesMissed) {
                if (!this.lastPosition || this.videoController.trackingData.length < 2) return;

                const lastData = this.videoController.trackingData[this.videoController.trackingData.length - 1];
                const currentTime = this.videoController.video.currentTime;
                
                // 算每一幀的時間間隔
                const timeStep = (currentTime - lastData.time) / framesMissed;

                // 為每個漏掉的幀創建插值點
                for (let i = 1; i < framesMissed; i++) {
                    const interpolatedTime = lastData.time + (timeStep * i);
                    const progress = i / framesMissed;

                    // 線性插值計算位置
                    const interpolatedPoint = {
                        time: interpolatedTime,
                        x: lastData.x + (this.lastPosition.x - lastData.x) * progress,
                        y: lastData.y + (this.lastPosition.y - lastData.y) * progress
                    };

                    this.videoController.trackingData.push(interpolatedPoint);
                }
            }

            findTargetInRegion(imageData, targetColor, tolerance, searchRegion, recursionDepth = 0) {
                // 添加最大递归深度限制
                const MAX_RECURSION_DEPTH = 2;
                if (recursionDepth >= MAX_RECURSION_DEPTH) {
                    return null;
                }

                const width = imageData.width;
                let sumX = 0;
                let sumY = 0;
                let count = 0;
                const sampleScale = 2; // 采样间隔，提高性能

                // 确保搜索区域在有效范围内
                const startX = Math.max(0, Math.floor(searchRegion.x));
                const startY = Math.max(0, Math.floor(searchRegion.y));
                const endX = Math.min(imageData.width, Math.ceil(searchRegion.x + searchRegion.width));
                const endY = Math.min(imageData.height, Math.ceil(searchRegion.y + searchRegion.height));

                // 在搜索区域内寻找匹配的像素
                for (let y = startY; y < endY; y += sampleScale) {
                    for (let x = startX; x < endX; x += sampleScale) {
                        const index = (y * width + x) * 4;
                        const r = imageData.data[index];
                        const g = imageData.data[index + 1];
                        const b = imageData.data[index + 2];

                        if (this.isColorMatch(r, g, b, targetColor, tolerance)) {
                            sumX += x;
                            sumY += y;
                            count++;
                        }
                    }
                }

                // 如果找到匹配的像素
                if (count > 0) {
                    return {
                        centerX: sumX / count,
                        centerY: sumY / count,
                        size: count
                    };
                }

                // 如果在当前搜索区域内没找到，且还有上一次的位置记录
                if (this.lastPosition && recursionDepth < MAX_RECURSION_DEPTH) {
                    // 扩大搜索范围
                    const expandedRegion = {
                        x: Math.max(0, this.lastPosition.x - this.searchRadius * (recursionDepth + 2)),
                        y: Math.max(0, this.lastPosition.y - this.searchRadius * (recursionDepth + 2)),
                        width: Math.min(imageData.width, this.searchRadius * (recursionDepth + 2) * 2),
                        height: Math.min(imageData.height, this.searchRadius * (recursionDepth + 2) * 2)
                    };

                    // 递归调用时增加深度计数
                    return this.findTargetInRegion(imageData, targetColor, tolerance, expandedRegion, recursionDepth + 1);
                }

                return null;
            }

            isColorMatch(r, g, b, targetColor, tolerance) {
                const colorDiff = Math.sqrt(
                    Math.pow(r - targetColor.r, 2) +
                    Math.pow(g - targetColor.g, 2) +
                    Math.pow(b - targetColor.b, 2)
                );
                return colorDiff <= tolerance;
            }

            drawDetectedPoints() {
                const ctx = this.videoController.ctx;
                const video = this.videoController.video;
                const canvas = this.videoController.trackingCanvas;
                const rect = canvas.getBoundingClientRect();

                const displayScale = rect.width / canvas.width;
                const circleRadius = 5 / displayScale;
                const lineWidth = 2 / displayScale;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                if (this.trailMode === 'hide') {
                    // 繪製最新的點
                    if (this.detectedPoints.length > 0) {
                        const lastPoint = this.detectedPoints[this.detectedPoints.length - 1];
                        this.drawPoint(ctx, lastPoint, 1, circleRadius, lineWidth);
                    }
                    return;
                }

                // 顯示或淡出模式
                this.detectedPoints.forEach((point, index) => {
                    let opacity = 1;
                    if (this.trailMode === 'fade' && this.detectedPoints.length > this.trailLength) {
                        // 計算漸變透明度
                        const fadeStart = Math.max(0, this.detectedPoints.length - this.trailLength);
                        if (index < fadeStart) {
                            opacity = index / fadeStart;
                        }
                    }
                    this.drawPoint(ctx, point, opacity, circleRadius, lineWidth);
                });
            }

            drawPoint(ctx, point, opacity, circleRadius, lineWidth) {
                const displayX = (point.x / this.videoController.video.videoWidth) * this.videoController.trackingCanvas.width;
                const displayY = (point.y / this.videoController.video.videoHeight) * this.videoController.trackingCanvas.height;

                ctx.beginPath();
                ctx.strokeStyle = `rgba(255, 0, 0, ${opacity})`;
                ctx.lineWidth = lineWidth;
                ctx.arc(displayX, displayY, circleRadius, 0, 2 * Math.PI);
                ctx.stroke();
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            setupManualTracking() {
                this.videoController.trackingCanvas.addEventListener('click', (e) => {
                    if (!this.isManualMode) return;

                    const rect = this.videoController.trackingCanvas.getBoundingClientRect();
                    
                    // 計算點擊位置相對於畫布的實際座標
                    const x = (e.clientX - rect.left) * (this.videoController.trackingCanvas.width / rect.width);
                    const y = (e.clientY - rect.top) * (this.videoController.trackingCanvas.height / rect.height);

                    // 添加新的追蹤點
                    const newPoint = {
                        time: this.videoController.video.currentTime,
                        x: x,
                        y: y
                    };

                    this.manualPoints.push(newPoint);

                    // 按時間排序
                    this.manualPoints.sort((a, b) => a.time - b.time);
                    
                    // 更新追蹤數據
                    this.videoController.trackingData = [...this.manualPoints];
                    
                    // 更新圖表
                    graphRenderer.updateGraphs(this.videoController.trackingData);
                    
                    // 重新繪製所有點
                    this.drawManualPoints();
                });

                // 在影片時間更新時重新繪製追蹤點
                this.videoController.video.addEventListener('timeupdate', () => {
                    if (this.isManualMode) {
                        this.drawManualPoints();
                    }
                });
            }

            drawManualPoints() {
                const ctx = this.videoController.ctx;
                const video = this.videoController.video;
                const canvas = this.videoController.trackingCanvas;
                const currentTime = video.currentTime;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                if (this.trailMode === 'hide') {
                    // 只顯示當前時間之前的最後一個點
                    const lastValidPoint = [...this.manualPoints]
                        .reverse()
                        .find(point => point.time <= currentTime);
                    
                    if (lastValidPoint) {
                        this.drawManualPoint(ctx, lastValidPoint, 1, this.manualPoints.indexOf(lastValidPoint));
                    }
                    return;
                }

                this.manualPoints.forEach((point, index) => {
                    let opacity = point.time <= currentTime ? 1 : 0.3;
                    
                    if (this.trailMode === 'fade' && this.manualPoints.length > this.trailLength) {
                        const fadeStart = Math.max(0, this.manualPoints.length - this.trailLength);
                        if (index < fadeStart && point.time <= currentTime) {
                            opacity *= index / fadeStart;
                        }
                    }

                    this.drawManualPoint(ctx, point, opacity, index);
                });
            }

            drawManualPoint(ctx, point, opacity, index) {
                const rect = this.videoController.trackingCanvas.getBoundingClientRect();
                const scaleX = this.videoController.trackingCanvas.width / rect.width;
                const scaleY = this.videoController.trackingCanvas.height / rect.height;
                
                // 計算點在畫布上的位置
                const displayX = (point.x / this.videoController.video.videoWidth) * this.videoController.trackingCanvas.width;
                const displayY = (point.y / this.videoController.video.videoHeight) * this.videoController.trackingCanvas.height;

                // 設置固定的螢幕像素大小（根據縮放比例調）
                const pointRadius = 5 * scaleX;    // 更大的點
                const lineWidth = 2 * scaleX;       // 更粗的線
                const fontSize = 10 * scaleX;       // 更大的字體
                const numberOffset = 15 * scaleY;   // 數字與點的距離

                // 繪製點
                ctx.beginPath();
                ctx.strokeStyle = `rgba(255, 255, 0, ${opacity})`;
                ctx.fillStyle = `rgba(255, 0, 0, ${opacity})`;
                ctx.lineWidth = lineWidth;
                
                ctx.arc(displayX, displayY, pointRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // 繪製序號
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.strokeStyle = `rgba(0, 0, 0, ${opacity})`;
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // 繪製數字外框
                ctx.lineWidth = lineWidth;
                ctx.strokeText(index + 1, displayX, displayY - numberOffset);
                
                // 繪製數字
                ctx.fillText(index + 1, displayX, displayY - numberOffset);

                // 連接相鄰點
                if (index > 0) {
                    const prevPoint = this.manualPoints[index - 1];
                    const prevX = (prevPoint.x / this.videoController.video.videoWidth) * this.videoController.trackingCanvas.width;
                    const prevY = (prevPoint.y / this.videoController.video.videoHeight) * this.videoController.trackingCanvas.height;
                    
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(255, 255, 0, ${opacity})`;
                    ctx.lineWidth = lineWidth;
                    ctx.moveTo(prevX, prevY);
                    ctx.lineTo(displayX, displayY);
                    ctx.stroke();
                }
            }

            setupTrailMode() {
                const toggleButton = document.getElementById('toggleTrailMode');
                toggleButton.addEventListener('click', () => {
                    switch (this.trailMode) {
                        case 'show':
                            this.trailMode = 'fade';
                            toggleButton.textContent = '軌跡模式: 淡出';
                            break;
                        case 'fade':
                            this.trailMode = 'hide';
                            toggleButton.textContent = '軌跡模式: 關閉';
                            break;
                        case 'hide':
                            this.trailMode = 'show';
                            toggleButton.textContent = '軌跡模式: 顯示';
                            break;
                    }
                    // 重新繪製畫面
                    if (this.isManualMode) {
                        this.drawManualPoints();
                    } else {
                        this.drawDetectedPoints();
                    }
                });
            }
        }

        class GraphRenderer {
            constructor() {
                this.xtCanvas = document.getElementById('xtGraph');
                this.ytCanvas = document.getElementById('ytGraph');
                this.xtCtx = this.xtCanvas.getContext('2d');
                this.ytCtx = this.ytCanvas.getContext('2d');
                
                // 設置圖表尺寸
                this.xtCanvas.width = 400;
                this.xtCanvas.height = 200;
                this.ytCanvas.width = 400;
                this.ytCanvas.height = 200;
                
                this.vxtCanvas = document.getElementById('vxtGraph');
                this.vytCanvas = document.getElementById('vytGraph');
                this.vxtCtx = this.vxtCanvas.getContext('2d');
                this.vytCtx = this.vytCanvas.getContext('2d');
                
                // 設置速度圖表的尺寸與 X-T 圖相同
                this.vxtCanvas.width = 400;
                this.vxtCanvas.height = 200;
                this.vytCanvas.width = 400;
                this.vytCanvas.height = 200;
                
                // 設置邊距
                this.margin = {
                    left: 40,
                    right: 20,
                    top: 20,
                    bottom: 30
                };

                this.setupTabs();
                
                // 確保初始狀態下位置圖表是可見的
                document.getElementById('positionTab').style.display = 'block';
            }

            setupTabs() {
                const tabButtons = document.querySelectorAll('.tab-button');
                const tabs = document.querySelectorAll('.tab-content');
                
                // 設置初始狀態
                tabs[0].style.display = 'block';  // 位置圖表預設顯示
                tabButtons[0].classList.add('active');
                
                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        // 移除所有活動狀態
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        tabs.forEach(tab => tab.style.display = 'none');
                        
                        // 設置當前頁簽為活動狀態
                        button.classList.add('active');
                        const tabId = button.getAttribute('data-tab') + 'Tab';
                        document.getElementById(tabId).style.display = 'block';
                    });
                });
            }

            updateGraphs(trackingData) {
                if (trackingData.length < 2) return;
                
                this.clearGraphs();
                this.drawXTGraph(trackingData);
                this.drawYTGraph(trackingData);
                this.drawVelocityGraphs(trackingData);
            }

            clearGraphs() {
                this.xtCtx.clearRect(0, 0, this.xtCanvas.width, this.xtCanvas.height);
                this.ytCtx.clearRect(0, 0, this.ytCanvas.width, this.ytCanvas.height);
                this.vxtCtx.clearRect(0, 0, this.vxtCanvas.width, this.vxtCanvas.height);
                this.vytCtx.clearRect(0, 0, this.vytCanvas.width, this.vytCanvas.height);
            }

            drawAxes(ctx, maxTime, maxValue, minValue, label) {
                const graphWidth = ctx.canvas.width - this.margin.left - this.margin.right;
                const graphHeight = ctx.canvas.height - this.margin.top - this.margin.bottom;

                // 繪製外框
                ctx.beginPath();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.rect(this.margin.left, this.margin.top, graphWidth, graphHeight);
                ctx.stroke();

                // 繪製座標軸
                ctx.beginPath();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                
                // X軸
                ctx.moveTo(this.margin.left, ctx.canvas.height - this.margin.bottom);
                ctx.lineTo(ctx.canvas.width - this.margin.right, ctx.canvas.height - this.margin.bottom);
                
                // Y軸
                ctx.moveTo(this.margin.left, this.margin.top);
                ctx.lineTo(this.margin.left, ctx.canvas.height - this.margin.bottom);
                ctx.stroke();

                // 繪製刻度
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                
                // Y軸刻度
                const yStep = (maxValue - minValue) / 5;
                for (let i = 0; i <= 5; i++) {
                    const y = this.margin.top + (graphHeight * (5 - i) / 5);
                    const value = (minValue + yStep * i).toFixed(1);
                    ctx.fillText(value.toString(), this.margin.left - 5, y);
                    
                    // 網格線
                    ctx.beginPath();
                    ctx.strokeStyle = '#eee';
                    ctx.lineWidth = 1;
                    ctx.moveTo(this.margin.left, y);
                    ctx.lineTo(ctx.canvas.width - this.margin.right, y);
                    ctx.stroke();
                }

                // 加粗 0 的位置的線
                if (minValue < 0 && maxValue > 0) {
                    const zeroY = this.margin.top + (graphHeight * (maxValue / (maxValue - minValue)));
                    ctx.beginPath();
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 1; // 加粗線條
                    ctx.moveTo(this.margin.left, zeroY);
                    ctx.lineTo(ctx.canvas.width - this.margin.right, zeroY);
                    ctx.stroke();
                }

                // X軸刻度
                const xStep = maxTime / 5;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                for (let i = 0; i <= 5; i++) {
                    const x = this.margin.left + (graphWidth * i / 5);
                    const value = (xStep * i).toFixed(1);
                    ctx.fillText(value + 's', x, ctx.canvas.height - this.margin.bottom + 5);
                    
                    // 網格線
                    ctx.beginPath();
                    ctx.strokeStyle = '#eee';
                    ctx.lineWidth = 1;
                    ctx.moveTo(x, this.margin.top);
                    ctx.lineTo(x, ctx.canvas.height - this.margin.bottom);
                    ctx.stroke();
                }

                // 添加標籤
                ctx.save();
                ctx.translate(3, ctx.canvas.height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.fillText(label, 0, 0);
                ctx.restore();
            }

            drawXTGraph(data) {
                const maxTime = Math.max(...data.map(d => d.time));
                const maxX = Math.max(...data.map(d => d.x));
                
                const graphWidth = this.xtCanvas.width - this.margin.left - this.margin.right;
                const graphHeight = this.xtCanvas.height - this.margin.top - this.margin.bottom;
                
                // 繪製座標軸和網格
                this.drawAxes(this.xtCtx, maxTime, maxX, 0, 'X位置 (px)');
                
                // 繪製數據線
                this.xtCtx.beginPath();
                this.xtCtx.strokeStyle = 'blue';
                this.xtCtx.lineWidth = 2;
                
                data.forEach((point, i) => {
                    const x = this.margin.left + (point.time / maxTime * graphWidth);
                    const y = this.xtCanvas.height - this.margin.bottom - (point.x / maxX * graphHeight);
                    
                    if (i === 0) {
                        this.xtCtx.moveTo(x, y);
                    } else {
                        this.xtCtx.lineTo(x, y);
                    }
                });
                
                this.xtCtx.stroke();
            }

            drawYTGraph(data) {
                const maxTime = Math.max(...data.map(d => d.time));
                const maxY = Math.max(...data.map(d => d.y));
                
                const graphWidth = this.ytCanvas.width - this.margin.left - this.margin.right;
                const graphHeight = this.ytCanvas.height - this.margin.top - this.margin.bottom;
                
                // 繪製座標軸和網格
                this.drawAxes(this.ytCtx, maxTime, maxY, 0, 'Y位置 (px)');
                
                // 製數據
                this.ytCtx.beginPath();
                this.ytCtx.strokeStyle = 'red';
                this.ytCtx.lineWidth = 2;
                
                data.forEach((point, i) => {
                    const x = this.margin.left + (point.time / maxTime * graphWidth);
                    const y = this.ytCanvas.height - this.margin.bottom - (point.y / maxY * graphHeight);
                    
                    if (i === 0) {
                        this.ytCtx.moveTo(x, y);
                    } else {
                        this.ytCtx.lineTo(x, y);
                    }
                });
                
                this.ytCtx.stroke();
            }

            drawVelocityGraphs(data) {
                // 計算速度數據
                const velocityData = this.calculateVelocities(data);
                
                // 獲取 Vx 和 Vy 的最大和最小值
                const maxVx = Math.max(...velocityData.map(d => d.vx));
                const minVx = Math.min(...velocityData.map(d => d.vx));
                const maxVy = Math.max(...velocityData.map(d => d.vy));
                const minVy = Math.min(...velocityData.map(d => d.vy));
                
                // 繪製 X 方向速度圖
                this.drawVelocityGraph(this.vxtCtx, velocityData, maxVx, minVx, 'vx', 'X方向速度 (px/s)');
                
                // 繪製 Y 方向速度圖
                this.drawVelocityGraph(this.vytCtx, velocityData, maxVy, minVy, 'vy', 'Y方向速度 (px/s)');
            }

            calculateVelocities(data) {
                return data.map((point, index) => {
                    if (index === 0 || index === data.length - 1) {
                        return {
                            time: point.time,
                            vx: 0,
                            vy: 0
                        };
                    }
                    
                    const dt = data[index + 1].time - data[index - 1].time;
                    const vx = (data[index + 1].x - data[index - 1].x) / (2 * dt);
                    const vy = (data[index + 1].y - data[index - 1].y) / (2 * dt);
                    
                    return {
                        time: point.time,
                        vx: vx,
                        vy: vy
                    };
                });
            }

            drawVelocityGraph(ctx, data, maxValue, minValue, component, label) {
                const maxTime = Math.max(...data.map(d => d.time));
                
                const graphWidth = ctx.canvas.width - this.margin.left - this.margin.right;
                const graphHeight = ctx.canvas.height - this.margin.top - this.margin.bottom;
                
                // 繪製座標軸和網格
                this.drawAxes(ctx, maxTime, maxValue, minValue, label);
                
                // 繪製數據線
                ctx.beginPath();
                ctx.strokeStyle = component === 'vx' ? 'blue' : 'red';
                ctx.lineWidth = 2;
                
                data.forEach((point, i) => {
                    const x = this.margin.left + (point.time / maxTime * graphWidth);
                    const y = ctx.canvas.height - this.margin.bottom - ((point[component] - minValue) / (maxValue - minValue) * graphHeight);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
            }
        }

        // 初始化
        const videoController = new VideoController();
        const objectTracker = new ObjectTracker(videoController);
        const graphRenderer = new GraphRenderer();
    </script>
</body>
</html>
