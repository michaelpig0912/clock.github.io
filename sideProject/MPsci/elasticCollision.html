<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>彈性碰撞實驗</title>
  <style>
    /* 設置全螢幕和視窗的黑色背景 */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background-color: #000000; /* 黑色背景 */
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* 16:9 比例的容器 */
    #aspect-ratio-container {
      position: relative;
      width: 100%;
      max-width: 100vw;
      max-height: 100vh;
      /* 使用 16:9 的比例 */
      aspect-ratio: 16 / 9;
      background-color: #ffffff; /* 背景色可以根據需要調整 */
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    #container {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #ffffff;
    }

    #canvas-container {
      width: 80%;
      height: 100%;
      background-color: #000000;
      position: relative;
    }

    #velocity-chart-container {
      width: 20%;
      height: 100%;
      background-color: #f4f4f4;
      box-sizing: border-box;
      padding: 10px;
      position: relative;
    }

    #velocity-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      font-family: Arial, sans-serif;
      font-size: 16px;
      color: white;
    }

    #button-container {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
    }

    #pause-btn, #fullscreen-btn {
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
      margin-right: 10px;
    }

    #control-panel {
      position: absolute;
      bottom: 10px;
      left: 25%;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
    }

    .mass-control {
      margin-bottom: 10px;
    }

    .mass-control label {
      display: inline-block;
      width: 100px;
    }

    /* 全螢幕時的樣式 */
    .fullscreen #canvas-container {
      width: 80%;
      height: 100%;
    }

    .fullscreen #velocity-chart-container {
      width: 20%;
      height: 100%;
      position: absolute;
      top: 50px;
      right: 10px;
      background-color: rgba(255, 255, 255, 0.8);
    }

    /* 確保內容不會溢出 */
    canvas {
      max-width: 100%;
      max-height: 100%;
    }
  </style>
</head>
<body>
  <div id="aspect-ratio-container">
    <div id="container">
      <div id="canvas-container"></div>
      <div id="velocity-chart-container">
        <canvas id="velocity-chart"></canvas>
      </div>
      <div id="velocity-info"></div>
      <div id="button-container">
        <button id="pause-btn">暫停</button>
        <button id="fullscreen-btn">全螢幕</button>
      </div>
      <div id="control-panel">
        <div class="mass-control">
          <label for="mass1">Box 1 質量:</label>
          <input type="range" id="mass1" min="1" max="1000" value="200">
          <span id="mass1-value">200</span>
        </div>
        <div class="mass-control">
          <label for="mass2">Box 2 質量:</label>
          <input type="range" id="mass2" min="1" max="1000" value="200">
          <span id="mass2-value">200</span>
        </div>
      </div>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // Matter.js module aliases
    const { Engine, Render, World, Bodies, Mouse, MouseConstraint, Events, Runner } = Matter;

    // 創建引擎
    const engine = Engine.create({
      enableSleeping: false,
      constraintIterations: 10,
      positionIterations: 10,
      velocityIterations: 10
    });
    const runner = Runner.create();
    engine.world.gravity.x = 0; // x 分量設為 0
    engine.world.gravity.y = 0; // y 分量設為 0

    // 創建渲染器
    const render = Render.create({
      element: document.getElementById("canvas-container"),
      engine: engine,
      options: {
        width: document.getElementById("canvas-container").clientWidth,
        height: document.getElementById("canvas-container").clientHeight,
        wireframes: false
      }
    });

    // 創建地面
    const ground = Bodies.rectangle(render.options.width / 2, render.options.height - 50, render.options.width, 100, { isStatic: true, friction: 0, restitution: 0, label: "ground" });

    // 創建牆壁
    const wallOptions = { isStatic: true, label: "wall" };
    const leftWall = Bodies.rectangle(0, render.options.height / 2, 10, render.options.height, wallOptions);
    const rightWall = Bodies.rectangle(render.options.width, render.options.height / 2, 10, render.options.height, wallOptions);
    const topWall = Bodies.rectangle(render.options.width / 2, 0, render.options.width, 10, wallOptions);
    const bottomWall = Bodies.rectangle(render.options.width / 2, render.options.height, render.options.width, 10, wallOptions);

    // 創建盒子1
    const box1 = Bodies.rectangle(render.options.width / 2 - 100, render.options.height - 150, 100, 100, { 
      restitution: 1, 
      friction: 0, 
      mass: 200, 
      inertia: Infinity,  
      frictionAir: 0,
      velocity: { x: 2, y: -2 }  // 設置較小的初始速度
    });

    // 創建盒子2
    const box2 = Bodies.rectangle(render.options.width / 2 + 100, render.options.height - 150, 100, 100, { 
      restitution: 1, 
      friction: 0, 
      mass: 200, 
      inertia: Infinity,  
      frictionAir: 0,
      velocity: { x: -2, y: 2 }  // 設置較小的初始速度
    });

    // 將物體加入世界
    World.add(engine.world, [ground, leftWall, rightWall, topWall, bottomWall, box1, box2]);

    // 啟動渲染器
    Render.run(render);

    // 滑鼠互動
    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine, {
      mouse: mouse,
      constraint: {
        stiffness: 0.2,
        render: { visible: false }
      }
    });

    World.add(engine.world, mouseConstraint);

    // 保持滑鼠與渲染同步
    render.mouse = mouse;

    // 顯示盒子速度
    const velocityInfo = document.getElementById("velocity-info");

    function updateVelocityInfo() {
      const velocity1 = box1.velocity;
      const speed1 = Math.sqrt(velocity1.x ** 2 + velocity1.y ** 2);
      const angle1 = Math.atan2(velocity1.y, velocity1.x);

      const velocity2 = box2.velocity;
      const speed2 = Math.sqrt(velocity2.x ** 2 + velocity2.y ** 2);
      const angle2 = Math.atan2(velocity2.y, velocity2.x);

      velocityInfo.innerHTML = `
        Box 1: 速度: ${speed1.toFixed(2)}, 角度: ${angle1.toFixed(2)}<br>
        Box 2: 速度: ${speed2.toFixed(2)}, 角度: ${angle2.toFixed(2)}
      `;
    }

    Events.on(render, "afterRender", function() {
      updateVelocityInfo(box1);
    });

    // Velocity-Time Chart
    const velocityChartCanvas = document.getElementById("velocity-chart");
    const velocityChart = new Chart(velocityChartCanvas, {
      type: "line",
      data: {
        labels: [],
        datasets: [{
          label: "Box 1 Velocity",
          data: [],
          backgroundColor: "rgba(75, 192, 192, 0.2)",
          borderColor: "rgba(75, 192, 192, 1)",
          borderWidth: 1
        }, {
          label: "Box 2 Velocity",
          data: [],
          backgroundColor: "rgba(192, 75, 75, 0.2)",
          borderColor: "rgba(192, 75, 75, 1)",
          borderWidth: 1
        }]
      },
      options: {
        responsive: false,
        maintainAspectRatio: false,
        scales: {
          x: {
            title: {
              display: true,
              text: "Time (s)"
            }
          },
          y: {
            title: {
              display: true,
              text: "Velocity"
            },
            beginAtZero: true
          }
        }
      }
    });

    let isPaused = false;
    const pauseBtn = document.getElementById("pause-btn");

    pauseBtn.addEventListener("click", function() {
      if (isPaused) {
        isPaused = false;
        pauseBtn.textContent = "暫停";
        Runner.run(runner, engine);
      } else {
        isPaused = true;
        pauseBtn.textContent = "繼續";
        Runner.stop(runner);
      }
    });

    // 獲取質量控制元素
    const mass1Control = document.getElementById('mass1');
    const mass2Control = document.getElementById('mass2');
    const mass1Value = document.getElementById('mass1-value');
    const mass2Value = document.getElementById('mass2-value');

    // 更新質量的函數
    function updateMass(box, massControl, massValue) {
      const newMass = parseInt(massControl.value);
      Matter.Body.setMass(box, newMass);
      massValue.textContent = newMass;
    }

    // 為質量控制添加事件監聽器
    mass1Control.addEventListener('input', () => updateMass(box1, mass1Control, mass1Value));
    mass2Control.addEventListener('input', () => updateMass(box2, mass2Control, mass2Value));

    Events.on(engine, "afterUpdate", function() {
      if (!isPaused) {
        const MAX_DATA_POINTS = 500; // 最大資料點數量

        if (velocityChart.data.labels.length > MAX_DATA_POINTS) {
          velocityChart.data.labels.shift(); // 移除最早的標籤

          velocityChart.data.datasets.forEach(dataset => {
            dataset.data.shift(); // 移除最早的資料點
          });
        } 

        const velocity1 = Math.sqrt(box1.velocity.x ** 2 + box1.velocity.y ** 2);
        const velocity2 = Math.sqrt(box2.velocity.x ** 2 + box2.velocity.y ** 2);
        const time = engine.timing.timestamp * 0.001; // 轉換為秒

        velocityChart.data.labels.push(time.toFixed(2));
        velocityChart.data.datasets[0].data.push(velocity1.toFixed(2));
        velocityChart.data.datasets[1].data.push(velocity2.toFixed(2));
        velocityChart.update();

        updateVelocityInfo();
      }
    });

    // 運行引擎，設置較小的時間步長
    Runner.run(runner, engine);

    // 全螢幕功能
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    const body = document.body;
    const aspectRatioContainer = document.getElementById('aspect-ratio-container');

    fullscreenBtn.addEventListener('click', toggleFullScreen);

    function toggleFullScreen() {
      if (!document.fullscreenElement) {
        if (aspectRatioContainer.requestFullscreen) {
          aspectRatioContainer.requestFullscreen();
        } else if (aspectRatioContainer.mozRequestFullScreen) { // Firefox
          aspectRatioContainer.mozRequestFullScreen();
        } else if (aspectRatioContainer.webkitRequestFullscreen) { // Chrome, Safari and Opera
          aspectRatioContainer.webkitRequestFullscreen();
        } else if (aspectRatioContainer.msRequestFullscreen) { // IE/Edge
          aspectRatioContainer.msRequestFullscreen();
        }
        fullscreenBtn.textContent = '退出全螢幕';
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
        fullscreenBtn.textContent = '全螢幕';
      }
    }

    // 監聽全螢幕變化事件
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleFullscreenChange);

    function handleFullscreenChange() {
      if (!document.fullscreenElement && !document.webkitIsFullScreen && !document.mozFullScreen && !document.msFullscreenElement) {
        fullscreenBtn.textContent = '全螢幕';
      }
      resizeRenderer();
    }

    function resizeRenderer() {
      // 獲取容器的實際大小
      const containerWidth = document.getElementById("canvas-container").clientWidth;
      const containerHeight = document.getElementById("canvas-container").clientHeight;

      // 更新渲染器大小
      render.bounds.max.x = containerWidth;
      render.bounds.max.y = containerHeight;
      render.options.width = containerWidth;
      render.options.height = containerHeight;
      Render.setPixelRatio(render, window.devicePixelRatio);

      // 更新物體的位置
      Matter.Body.setPosition(ground, { x: containerWidth / 2, y: containerHeight - 50 });
      Matter.Body.setPosition(leftWall, { x: 0, y: containerHeight / 2 });
      Matter.Body.setPosition(rightWall, { x: containerWidth, y: containerHeight / 2 });
      Matter.Body.setPosition(topWall, { x: containerWidth / 2, y: 0 });
      Matter.Body.setPosition(bottomWall, { x: containerWidth / 2, y: containerHeight });

      // 更新球的初始位置（可選）
      Matter.Body.setPosition(box1, { x: containerWidth / 2 - 100, y: containerHeight - 150 });
      Matter.Body.setPosition(box2, { x: containerWidth / 2 + 100, y: containerHeight - 150 });

      // 更新渲染
      Render.lookAt(render, {
        min: { x: 0, y: 0 },
        max: { x: containerWidth, y: containerHeight }
      });
    }

    // 初始化渲染器大小
    window.addEventListener('resize', resizeRenderer);
    resizeRenderer();
  </script>
</body>
</html>
